/******************************************************************************************************************************
*Autor:	Andreas Pister
*Company: Hochschule Heilbronn
*
*Description:	This nodes was build for a student project. Terms of use are only for the Field-Robot-Event. 
*				Commercial using ore Selling are excluded. 
*				Subscribes an sensor_msgs of type LaserScan. The scan_data have to be detect in a corfield
*				according to the rules of the Field-Robot-Event 2018.
*				The end of the current row will be deteced and the distance bewtween the robot_zero_point and
*				the end of the row are be published.		
*
*
*Input:	
*				y_detection_range(float):: defines the y-range where the Node search the end of the row
*
*				detection_threshold(float)::defines the space between 2 Points  until the node will deteced the end 
*			
*				max_error_dist(float)::defines the maximum difference between the old and the new end of the row 
*							  		   otherwise it will throw an arror  
*		
*				max_error_count(int)::defines the maximum count of following errors befor the new distance willt set as true  
*
*				The node needs a published sensor_msgs type LaserScan
*
*
*Output:
*				Publish a std_msgs type Float64 
*				Name :"end_row/distance"
*
*				wihle the outputvalue cotains -1, the node detect no valid distance
*
******************************************************************************************************************************/

#include <ros/ros.h>
#include <sensor_msgs/LaserScan.h>
#include <sensor_msgs/PointCloud.h>
#include <tf/transform_listener.h>
#include <std_msgs/Float64.h>
#include <laser_geometry/laser_geometry.h>
#include <list>

#define TF_FRAME "base_laser_link"			//Transformation-frame of the subscribed scan_data

// Basic values
#define y_detection_range_basic 1.0			//Y-range where the data are used, +- out of 0  
#define detection_threshold_basic 1.5		//distance between end of line and next posible detection
#define max_error_dist_basic 0.3			//difference between last and new distance
#define max_error_count_basic 10			//Maximum error repeats
#define max_detection_dist_basic -1.0

float y_detection_range;
float detection_threshold;
float max_error_dist;
float max_error_count;
float max_detection_dist;

float distance =-1.0;				//current distance
float old_distance = -1.0;			//old distance
int count_error_value = 0;			//counter for error detection


float values[4] ={0};
ros::Publisher pub_distance;

//**************************************************************
//checking the detected distance against the last valide distance
//**************************************************************
bool checking_value(float distance_1)
{
	if(count_error_value>=max_error_count)
	{
		count_error_value=0;
		old_distance=distance_1;
		//ROS_INFO("Test 1");
		return true;
	}
	else if (distance_1<old_distance & (distance_1+max_error_dist)>=old_distance)
	{
		old_distance = distance_1;
		count_error_value=0;
		//ROS_INFO("Test 2");
		return true;
	}	
	else if (distance_1>old_distance & (distance_1-max_error_dist)<=old_distance)
	{
		old_distance = distance_1;
		count_error_value=0;
		//ROS_INFO("Test 3");
		return true;
	}
	else
	{
		//ROS_INFO("Test 4");
		count_error_value++;
		return false;
	}
}


//**************************************************************
//detect the end of the row by filtering the sector of data
//**************************************************************
void deteced(const sensor_msgs::LaserScan::ConstPtr& points)
{
	tf::TransformListener tf_listener;
	laser_geometry::LaserProjection transformation;
	sensor_msgs::PointCloud cloud;
    transformation.transformLaserScanToPointCloud(TF_FRAME,*points, cloud,tf_listener);
	std::list<float> hysteri;
	
	float temp_distance =-1.0;
	
	//creates a List of all distance in the sector +-y_detection_range
	for (int i = 0; i<720; i++)
	{
		if (cloud.points[i].y<y_detection_range & cloud.points[i].y>(y_detection_range*-1) & cloud.points[i].x>0.0)
		{
			hysteri.push_back(cloud.points[i].x);
		}		
	}
	
	//Sorting list and looking for the right value
	if(hysteri.empty()==false)
	{
		hysteri.sort();
		hysteri.push_back(0.0);
		//float test[hysteri.size()]=hysteri;
		std::list<float> ::iterator it;
		for(it = hysteri.begin(); it != hysteri.end(); it++)
		{
			float value_1 =*it;
			it++;
			float value_2 =*it;
			
			if((value_2-value_1)>=detection_threshold)
			{
				temp_distance=value_1;
				break;
			}
			else if(value_2==0.0 & value_1>0.0)
			{
				temp_distance=value_1;
				break;
			}
			it--;
		}
	}
	//checking value
	if (checking_value(temp_distance) & temp_distance>=0.0){
		values[0]=values[1];
		values[1]=values[2];
		values[2]=values[3];
		values[3]=temp_distance;
		
	}
	else
	{
		values[0]=values[1];
		values[1]=values[2];
		values[2]=values[3];
	}
	
	//middle
	distance=(values[0]+values[1]+values[2]+values[3])/4;
	if (0.0>max_detection_dist){}
	else if(distance > max_detection_dist)
	{
		distance=max_detection_dist;
	}
	std_msgs::Float64 msg;
	msg.data = distance;
	pub_distance.publish(msg);
	//ROS_INFO("distance to end of row: %f",distance);
					 
}


//**************************************************************
//Mainfunction initialize nodehandler publisher subscriber
//**************************************************************
int main(int argc, char **argv)
{
	int range =1000;
	ros::init(argc, argv, "end_row");

	ros::NodeHandle n;
	ros::Rate loop_rate(10);
	ROS_INFO("Programm Start");
	
	//geting Rosparameter
	if(!n.getParam("y_detection_range", y_detection_range))
	{
		ROS_INFO("y_detection_range are not found");
		y_detection_range=y_detection_range_basic ;
	}
	//else
	//ROS_INFO("%f",y_detection_range);
	
	if(!n.getParam("detection_threshold", detection_threshold))
	{
		ROS_INFO("detection_threshold are not found");
		detection_threshold=detection_threshold_basic ;
	}
	//else
	//ROS_INFO("%f",detection_threshold);
	
	if(!n.getParam("max_error_dist", max_error_dist))
	{
		ROS_INFO("max_error_dist are not found");
		max_error_dist=max_error_dist_basic ;
	}
	//else
	//ROS_INFO("%f",max_error_dist);
	
	if(!n.getParam("max_error_count", max_error_count))
	{
		ROS_INFO("max_error_count are not found");
		max_error_count=max_error_count_basic ;
	}
	//else
	//ROS_INFO("%d",max_error_count);
	
	if(!n.getParam("max_detection_dist", max_detection_dist))
	{
		ROS_INFO("max_detection_dist are not found");
		max_detection_dist=max_detection_dist_basic ;
	}
	//else
	//ROS_INFO("%d",max_error_count);
	
	ros::Subscriber sub_message = n.subscribe("scan", range, deteced);
	pub_distance = n.advertise<std_msgs::Float64>("end_row/distance", range);
	ros::spin();
	
return 0;
	
}

